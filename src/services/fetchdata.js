useEffect(() => { if (selectedSource !== "Razuna") return; // only fetch for Razuna 
setLoadingAPI(true); 
 fetch("/api/v1/media/?alias=Razuna") 
 .then((res) => res.json()) 
 .then(async (responseData) => { const formatted = responseData.data.map((item) => ({ name: item.VID_FILENAME, id: item.VID_ID, duration: "-", status: "Okay", size: item.VID_SIZE_GB, type: item.VID_FILENAME.split("_")[0] || "Other" })); // --- Define batch fetch function --- const batchFetchMetadata = async (videos, batchSize = 20) => { const results = []; for (let i = 0; i < videos.length; i += batchSize) { const batch = videos.slice(i, i + batchSize); const batchResults = await Promise.all( batch.map(async (video) => { try { const res = await fetch(/api/v1/metadata/${video.id}); const meta = await res.json(); const d = meta?.data || {}; return { ...video, duration: d.timecode || "-", duration_seconds: d.duration_seconds || 0, fps: d.fps || "-", codec: d.codec || "-", width: d.width || "-", height: d.height || "-", bitrate: d.bitrate || "-", file_url: d.file_url || "#", }; } catch (err) { console.error(Metadata fetch failed for ${video.id}:, err); return video; } }) ); results.push(...batchResults); } return results; }; // --- CALL the batch fetch --- const withDurations = await batchFetchMetadata(formatted, 20); setRazunaData(withDurations); setFilteredDataRazuna(withDurations); setLoadingAPI(false); }) .catch((err) => { console.error("Fetch Error:", err); setLoadingAPI(false); }); }, [selectedSource]);